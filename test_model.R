########################
## 20241107
## SP: toying around with data and a base model
########################
library(nimble)

## read data (uto et el)
dataOrig <- read.table("data/OSCE_data.csv", header=TRUE, sep=",")

## data is in format Item, Rater, Examinee
str(dataOrig)

## Transform data to follow a tidy format (no NAs)
setting <- list(K = 4, n_person = 30, n_item = 30, n_rater = 5)
dataScores <- c()
for(i in 1:length(dataOrig[,1])){
  for(j in 3:length(dataOrig[1,])){
    if(!is.na(dataOrig[i, j])){
      dataScores <- rbind(dataScores, cbind(dataOrig[i,1:2], j-2, dataOrig[i, j]+1))
    }
  }
}
colnames(dataScores) <- c("Items","Raters","Examinees","Score")
str(dataScores)

## K = number of possible scores - index k 
## note that scores are defined from 1 to K, not from 0!
## n_person = number of students - index j
## n_item = number of items - index i
## n_rater = number of raters - index r

## data is in long format!
## in nimble the data will be the vector with all the scores
## we are going to use the vector of numeric indices (item, raters, examinee)
## to indicate the position of each score in the vector

items <- dataScores$Items
raters <- dataScores$Raters
examinees <- dataScores$Examinees


data <- list(y = dataScores$Score)


constants <- list(nTot= length(data$y),
                  n_person = length(unique(examinees)), 
                  n_item = length(unique(items)),
                  n_rater = length(unique(raters)),
                  items = items,
                  raters = raters,
                  examinees = examinees,
                  K = 4)
               
modelCode <- nimbleCode({

  for(i in 1:nTot) {
    ## Each observed score is generated by a categorical distribution
    y[i] ~ dcat(prob[i, 1:K])
  }

  for(k in 1:K) { 
        
      lambda[items[i]]*(eta[examinees[i]] - tau[raters[i]] - beta[items[i], k])
  }

  for(i in 1:I) {
    beta.tmp[i] ~ dnorm(0, var = 3)  
    logLambda.tmp[i] ~ dnorm(0.5, var = 0.5)   
  }



})